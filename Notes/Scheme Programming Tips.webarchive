bplist00—_WebMainResource’	
_WebResourceTextEncodingName_WebResourceFrameName^WebResourceURL_WebResourceData_WebResourceMIMETypeUUTF-8P_Ahttp://www.cs.duke.edu/brd/Teaching/dm/handouts/scheme-tips.shtmlOKï<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN"><html><head>
  <title>Scheme Programming Tips</title>
  <link rel="stylesheet" type="text/css" href="../cs18.css">
  <link rel="shortcut icon" href="../img/yinyang.ico">
</head>
<body>

<table class="title" align="center">
<tbody><tr>
  <td align="center">
CS 230
  </td>
</tr>
</tbody></table>

<h1>Scheme Programming Tips</h1>

<p>At this point, you should have seen at least the basic core of the
Scheme language -- its syntax, evaluation rules, and some special
forms.  From a purely logistical perspective, that's plenty to get you
started writing your own programs.  This document goes a bit further,
and talks about matters of programming style.  Despite the name,
<em>style</em> is about more than how your code looks -- style
encompasses a whole class of conventions that make it easier to read,
maintain, and debug your code.</p>

<ul class="menu">
  <li><a href="#formatting">Formatting Conventions</a>

  </li><li><a href="#efficiency">Programming Efficiency</a>
</li></ul>

<hr>

<h2><a name="formatting"></a>Formatting Conventions</h2>

<p>So why, you might wonder, should you care about issues like
formatting your code?</p>

<p>In almost any programming language, it is quite easy to write
programs that are correct, but at the same time completely unreadable
by humans.  If you don't believe me, here is a legal Scheme program to
compute the <var>n</var>th Fibonacci number, with all the formatting
removed:</p>

<pre><code>
(lambda(n)(let l((p 0)(c 1)(n n))(cond((&lt; n 1)c)(else(l c (+ p c)(- n 1))))))
</code></pre>

<p>Here is the same thing with nice neat indentation, descriptive
variable names, and comments:</p>

<pre><code>
<span class="comment">;; Compute the nth Fibonacci number</span>
(lambda (n)
  (let loop ((previous 0) (current 1) (remaining n))
    (cond ((&lt; remaining 1) current)
	  (else
	    (loop current 
	          (+ previous current)
		  (- remaining 1))))))
</code></pre>

<p>The computer does not care how you type your code; but when you are
testing and debugging your own programs, you yourself very much
<em>will</em> care.  (If you don't believe that, take some of the
examples which follow, and remove all the line-breaks and tabs.  Then
try to figure out which expressions go with which operators).</p>

<p>Fortunately, the built-in editor in DrScheme is very smart about
these issues, and will help you out by balancing your parentheses and
providing reasonable indentation.  But, even if you are working in
some other text editor, it is good to keep a few simple principles in
mind.  None of this is crucial to your understanding of the Scheme
language, but these rules of thumb can help make your life easier.</p>

<h3>Line Up Arguments Vertically</h3>

<p>When you are writing a combination that represents a function call,
you frequently will not have room to put all the arguments on the same
line, especially if those arguments are themselves complex
expressions.  It is a good idea to line up all the arguments in a
column, if you have to put them on separate lines:</p>

<pre><code>
(/ (factorial n)
   (* (factorial r)
      (factorial (- n r))))
   <span class="comment">^  ^----- arguments of '*'
   |-------- arguments of '/'</span>
</code></pre>

<h3>Indent to Indicate Nesting</h3>

<p>When you have a sequence of one or more expressions nested inside a
special form such as <tt>if</tt> or <tt>lambda</tt>, indent those
expressions a couple spaces to indicate that their relationship to the
special form:</p>

<pre><code>
(lambda (a b c)
  (display "This is the body of the 'lambda'")
  (newline)

  (let ((b^2 (* b b)))
    (display "This is the body of the 'let'")
    (newline)
    (/ (+ b^2 (sqrt (* 4 a c)))
    (* 2 a))))
  <span class="comment">^ ^------------- body of 'let'
  |--------------- body of 'lambda'</span>
</code></pre>

<h3>Don't Line Up Closing Parentheses</h3>

<p>In C and related programming languages, it is customary to line up
closing brackets, to indicate nesting structure, <i>e.g.:</i></p>

<pre><code>
<span class="comment">/* An example of brackets in C or C++ */</span>
if(a &gt;= b) {
  if(a &gt;= c) {
    if(a &gt;= d) {
      return a;
    }       <span class="comment">/* closing bracket for inner 'if'  */</span>
  }         <span class="comment">/* closing bracket for middle 'if' */</span>
}           <span class="comment">/* closing bracket for outer 'if'  */</span>
</code></pre>

<p>In Scheme programs, you should <em>not</em> adopt this convention.
The reason is, because everything is fully parenthesized, you will
wind up wasting a lot of space, and it becomes harder to read.  If you
indent your code carefully, the structure will be obvious anyway.  The
recommended style is:</p>

<pre><code>
<strong>Good:</strong>
  (if (&gt;= a b)
      (if (&gt;= a c)
          (if (&gt;= a d)
              a)))  <span class="comment">; all closing braces here</span>

<strong>Bad:</strong>
  (if (&gt;= a b)
      (if (&gt;= a c)
	  (if (&gt;= a d)
	      a
          ) <span class="comment">; ick!</span>
      ) <span class="comment">; yuck!</span>
  ) <span class="comment">; ouch!</span>
</code></pre>

<p>By stacking all your closing parentheses on one line, in any
reasonable editor which balances your parentheses, you can just keep
typing close parenthesis until it shows you that your whole expression
has been closed.</p>

<h3>Use Block Comments</h3>

<p>The semicolon (<tt>;</tt>) is used to introduce comments in a
Scheme program.  Everything from the semicolon to the end of the line
is considered a comment, and is ignored by the Scheme interpreter.  As
in all other programming languages, it is a good idea to comment your
Scheme code.</p>

<p>In general, avoid commenting each individual line of your program
-- if someone wants to know what your program does in that much
detail, they will read the code itself.  Nevertheless, it's worthwhile
to put a comment at the top of each function you define, describing
how you call it, and what it's supposed to do.  For instance:</p>

<pre><code>
<span class="comment">;; (solve n) - computes the solution to Merkw√ºrdig's Equation
;; for an integer value n.  Assumes n &gt; 0.</span>
(define solve
  (lambda ((n &lt;integer&gt;))
    ...))
</code></pre>

<p>It is also good to put comments at the top of each source file,
describing what the file contains, who wrote it, any general
requirements, and so forth.  For example:</p>

<pre><code>
<span class="comment">;;;
;;; mycode.scm
;;;
;;; by Jonathan Q. Public
;;; 
;;; This file contains code to solve systems of low-order complex 
;;; Merkw√ºrdig and Schreklich equations in Euclidean space.
;;; You need to have a copy of Bob Jones's freeware Frobulator 
;;; library in order to use these routines.
;;;</span>
</code></pre>

<p>Note that the number of semicolons you use doesn't matter; that's
merely a point of aesthetics.  Only one is necessary, to indicate the
comment.  One typical style is to use three semicolons for block
comments at the top of the file, two for comments describing a
function, and one for comments in the middle of the code.  Feel free
to adopt your own style; in many ways, consistency is more important
than form, in this matter.</p>

<p>Comments <em>can</em> be put on the same line as other code, but
keep them short and sweet.  Block comments outside the body of the
code are much easier to deal with.</p>

<h3>Use Reasonable Line Lengths</h3>

<p>Avoid using line lengths greater than 80 characters.  In fact, if
you plan to e-mail code, you would do well to limit your lines to 72
characters.  This helps other people when they try to read your code
on a screen which may well be narrower than yours, and more
importantly, makes it so that printouts of your code don't run off the
edge of the page.</p>

<p>If your lines are getting too long, move things down onto another
line.  The editor will help you keep everything lined up neatly.</p>

<h3>Other General Suggestions</h3>
<ul>
  <li>

  <p>Scheme source files should be given the extension ".scm" to the
  end of their names.  Apart from Windows, this is not required by
  most operating systems, but it makes it easier for you to quickly
  identify Scheme source files.</p> 

  </li><li>

  <p><strong>Include your name in all source files</strong> you write.
  It's also helpful if you include an indication of what assignment
  the code is for, and if you have solved multiple problems in one
  file, which code goes with what problem.</p>

  </li><li>

  <p><strong>Make backups of your working code.</strong> If you have
  something that works, and you want to go back and make some changes
  or experiment, make a copy of the file, and make your changes to the
  copy.  That way, you can always go back to what you had working
  before, in case your new stuff doesn't work out.</p>

  </li><li>

  <p>Related to the above, <strong>don't be afraid to start over.
  </strong> Too many times, I've seen students struggle with a broken
  piece of code long after they've figured out a better, easier way to
  solve the problem, just because they are emotionally invested in the
  work they've already done.  Don't throw good work after bad!  Often,
  putting aside your old solution, starting a new file, and beginning
  afresh will take <em>less time</em> than fixing the old one.</p>
</li></ul>

<hr>

<h2><a name="efficiency"></a>Programming Efficiency</h2>

<p>There are several issues of programming style beyond simple text
formatting, that can make your life easier as a programmer.  These are
not limited to Scheme, although they are presented here using Scheme
examples.</p>

<h3>Write Short Functions</h3>

<p>Write short functions, each of which performs a single,
well-defined operation.  Comment clearly what the function does,
before you write it.  Test it, before you use it.</p>

<p>Small functions are easier to read, write, test, debug, and
understand.  Small, well-focused functions are also easier to re-use,
which makes your future programs easier to construct, also.</p>

<h3>Use Descriptive Names</h3>

<p>The names of variables should give a clear idea of what the
variable represents, and the names of functions should clearly
indicate what they do.  If the purpose isn't clear from the name, then
include a short comment documenting what the variable or function is
for.</p>

<p>In Scheme, there are a few unofficial naming conventions which make
life a bit easier:</p>

<ul>
  <li>

  <p>Predicates (functions which answer only true or false) are
  typically given names ending in a question mark (?).  Examples
  include <tt>zero?</tt>, <tt>null?</tt>, <tt>number?</tt>, and
  <tt>odd?</tt>.  Some other dialects of Lisp, such as Common Lisp,
  use "p" for this purpose, instead, e.g. <tt>zerop</tt>,
  <tt>numberp</tt>, etc.</p>

  </li><li>

  <p>Functions and special forms which destructively modify the
  contents of a storage location (<i>e.g.,</i> assignment) are
  typically given names ending in an exclamation mark (!).  Examples
  include <tt>set!</tt>, <tt>set-car!</tt>, <tt>set-cdr!</tt>, and
  <tt>sort!</tt>.</p>

  </li><li>

  <p>Functions that construct a new instance of some data type begin
  with <tt>make-</tt>.  Examples include <tt>make-string</tt> and
  <tt>make-vector</tt>.</p>

  </li><li>

  <p>Global variables are given names that begin and end with
  asterisks (*), to keep them from interfering with locally bound
  variables.</p>
</li></ul>

<p>In addition, we will generally give variables used to define
classes names surrounded in angle brackets, e.g.
<tt>&lt;integer&gt;</tt>, <tt>&lt;string&gt;</tt>, etc.</p>

<p>In general, if you have a group of functions or variables with
related meaning, consider using some kind of conventional naming
strategy.  For instance, all of the classes in the DrScheme user
interface library are given names ending in a percent sign (%).
Conventions of this kind go a long way to make your code
understandable to other humans.</p>

<h3>Avoid Nesting 'if' and 'let' Unless Necessary</h3>

<p>Rather than nesting multiple <tt>if</tt> expressions, consider
using the <tt>cond</tt> special form.  Not only is it easier to read
(and less indentation work for you), but <tt>cond</tt> allows multiple
expressions in each clause, without having to use <tt>begin</tt>
explicitly.</p>

<p>Similarly, if you have a bunch of local variables, each of which
refers to the previous ones, use <tt>let*</tt> instead of nesting
multiple <tt>let</tt> expressions:</p>

<pre><code>
<strong>Bad:                            Good:</strong>
(if (zero? n)                   (cond ((zero? n) 0)
    0                                 ((= n 1) 1)
    (if (= n 1)                       (else
        1                               (* n (fact (- n 1)))))
        (* n (fact (- n 1)))))

(let ((x (car foo)))            (let* ((x (car foo))
  (let ((y (car x)))                   (y (car x))
    (let ((z (+ y 15)))                (z (+ y 15)))
      (cons z 6))))               (cons z 6)) 
</code></pre>

<h3>Avoid Global Variables</h3>

<p>A common inclination for programmers accustomed to C, Pascal, or
Fortran, is to use global variables to pass information around in a
program.  While this is legal, it is much less necessary in a
functional language such as Scheme, which has nested scopes and proper
closures.  Some reasonable uses of global variables include:</p>

<ul>
  <li><p>To provide hooks into the mechanisms of the program</p>

  </li><li><p>Parameters which, when changed, represent a major change
  in the behaviour of the program (e.g., default values)</p>

  </li><li><p>To pass information between programs</p>

  </li><li><p>To provide customizable defaults</p>
</li></ul>

<p>In general, a global variable is a reasonable thing to use when
function A needs to affect function B, but function A does not call
function B.  Otherwise, they should be avoided, since they can make
your program very confusing.</p>

<h3>Avoid Assignment</h3>

<p>Some otherwise functional languages such as Lisp and Scheme provide
assignment (<i>e.g.</i> <tt>set!</tt>), for reasons of efficiency.
However, do not be tempted to use assignment as you would in a C or
Java program.  And, if you do choose to use assignment, try to limit
assignment to locally bound variables.</p>

<h3>Write Modular Code</h3>

<p>Code is <span class="def">modular</span> if it is separated into
components which can be individually used and tested in isolation.
Actually, modularity isn't so much an all or nothing proposition, but
rather a matter of degree.  The fewer interdependencies the pieces of
your program have, the easier your task will be.</p>

<p>The main advantage of modularity is that it lets you test out each
piece of your program on its own, before you put the whole thing
together and try to make it run.  And, after you have put together the
pieces, modularity makes it easier for you to find and eliminate bugs
which inevitably crop up.</p>

<p>Another big advantage of modularity is that it makes your code
re-usable.  It is much easier to re-use code you have already written
<em>and tested</em> than to write the same thing from scratch
everytime.  For small programs, you might not care, but as you write
more and more code, you will find that getting into this discipline is
incredibly useful.</p>

<h3>Test Your Code</h3>

<p>This is actually more than a suggestion -- it's a requirement of
this course.  However, it's a good idea even when your grade does not
depend on it (more important things, such as your job, and possibly
the lives of the people using your software, <em>may</em> depend on
it anyway).</p>

<p>How do you know your code works?  One way might be to construct a
mathematical proof that it is correct.  We will talk about how to do
that in the course of this term.  Unless you do that, however, your
only alternative is to try the program out on some known input values,
and make sure it does what it is supposed to.  That is the key idea
behind code testing.</p>

<p>Each test generally consists of a set of input values, and the
corresponding (expected) output values.  To run the test, you invoke
your code on the input values, and make sure the actual output values
match the expected output values.  If they do not match, you know
there is a problem with your code.  If your tests are chosen
carefully, you may be able to gain some information about the nature
of the error, by looking at how the actual output values differ from
the expected output values.</p>

<p>Broadly speaking, these are some good criteria for choosing test
cases:</p>

<ul>
  <li>
  <p><strong>Invent test cases before you start to program.</strong>
  Before you even begin to write code, figure out what tests you could
  do to verify that your program works.  Write them down, and when you
  get finished, run them.  This helps you avoid the common problem 
  in programming, where we tend to adjust the input to fit the code,
  rather than the other way around.</p>

  </li><li>
  <p><strong>Choose test inputs that will cause all the program code
  to be executed.</strong> For instance, if your program chooses
  between two alternatives, make sure you choose inputs that can drive
  each alternative.</p>

  </li><li>
  <p><strong>Choose tests that are easily verified.</strong> You
  should be able to construct the expected output values for your
  tests easily, and verify that they are correct (the last thing you
  want to have to do is waste time debugging your <em>tests</em> as
  well as your code!)</p>
 
  </li><li>
  <p><strong>Choose some inputs outside the intended set.</strong> For
  instance, if your code is supposed to read a string of digits from
  the user, include a test case that gives it a string of letters and
  punctuation, to make sure your code can deal with it.</p>

  </li><li>
  <p><strong>Test boundary cases.</strong> A boundary case is a value
  that lies at the "edge" of the input data range, or a value lying
  between two parts of the input data range where the function behaves
  differently.  For instance, when testing an absolute value function
  on integers, test -1, 0, and 1.  The empty string and empty list are
  usually boundary cases for string and list processing programs.</p>

  </li><li>
  <p><strong>Avoid redundant cases.</strong> If you have a case that
  tests a particular behaviour of your code, don't include another
  case for the same behaviour.  The smaller your testing set, the
  easier your job is.</p>
</li></ul>

<p>If you establish a good set of tests, then each time you make a
change to your code, you can run a <span class="def"> regression
test</span>, making sure all your old tests still work after the
change was made.  This helps to keep new bugs from creeping in
unnoticed.</p>

<p>
<a href="http://www.cs.utexas.edu/users/EWD/">
Edsger Dijkstra</a>, the late and well-known computer scientist whose
research included techniques for proving the correctness of computer
programs, is quoted as having said that "testing can only reveal the
<em>presence</em> of bugs, not prove their <em>absence</em>."
However, well-chosen test cases are still a valuable tool in any
programmer's arsenal.</p>

<hr>
<!-- #include virtual="../ssi/handout-nav.ssi"-->
<hr>
<!-- #include virtual="../ssi/dept-foot.ssi"-->



</body></html>Ytext/html    ( F ] l ~ î ö õ ﬂLx                           LÇ