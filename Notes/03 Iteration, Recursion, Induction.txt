Topic: Procedures and Processes: Iteration, Recursion and Induction 
Date: Jan. 15, 2013
Handouts: induction, substitution-model.shtml
Examples: times.scm, prove-mult.scm
Notes: let.txt
Reading: SICP 1.2 to 1.2.2 (pg. 31-41)
         SDB  Ch. 4.1-4.2
----------------------------------------------------------------------

HANDOUT
  * Mathematical Induction 


Today's topics:
  * Iterative and Recursive Processes
  * Induction as a reasoning Tool

Part of a theme: FORMAL TOOLS for *understanding* our programs



----------------------------------------------------------------------


We have seen 
  * how to write Scheme expressions
  * how to evaluate them (Substitution Model)
  * how to define procedures, even recursive (=self-referential) ones.

Today, we dig a little deeper:
  1. Processes generated by procedures
  2. Correctness of the values they compute

Start developing models for reasoning about whether a procedure
computes the desired answer, building on the Substitution Model.


----------------------------------------------------------------------


Here are two kinds of multiplication procedures that compute a*b by
adding a b times (note type <integer> of b):

(define times-1 
  (lambda ((a <number>) (b <integer>))
    (if (= b 0) 
        0
        (+ a (times-1 a (- b 1)))))) 


[Write times-2 with LET and then change to LETREC]

(define times-2
  (lambda (a b)
    (letrec ((iter
              (lambda (c result)              
                (if (= c 0)
                    result
                    (iter (- c 1)
                          (+ result a))))))      
      (iter b 0))))
      

(times-2 4 5)

Because all the expressions are evaluated before the names are bound,
the normal version of `let' does not work for recursive procedures.

In order to define recursive functions, use `letrec' instead: It works
the same way as `let', but the names are visible to the expressions
being evaluated, so that you can define recursive procedures.

Note: LET and LETREC both temporarily associate name(s) with values,
within the body of the form.  Both are SPECIAL FORMS, the do not
follow the normal evaluation rule.

[Both LET and LETREC will be discussed further in lecture]

Note: ITER's first argument counts down from b by 1, while it's second
argument counts up from 0 by a.

----------------------------------------------------------------------


Let's trace through a computation:
  * Ignore apply stages, which are huge and basically all the same 

   (times-1 6 3)
   (+ 6 (times-1 6 2))
   (+ 6 (+ 6 (times-1 6 1)))
   (+ 6 (+ 6 (+ 6 (times-1 6 0))))
   (+ 6 (+ 6 (+ 6 0)))
   (+ 6 (+ 6 6))
   (+ 6 12)
   18

There are a whole slew of DEFERRED OPERATIONS,
  * All the +'s that haven't been done yet.

On the other hand, 
   

   (times-2 6 3)
   (iter 3 0)
   (iter (- 3 1) (+ 0 6))
   (iter 2 6)
   (iter 1 12)
   (iter 0 18)
   18

First arg counts down by 1, second arg counts up by 6.

Note that there are no operations waiting to happen on return.


----------------------------------------------------------------------


Both times-1 and times-2 are *syntactically* recursive procedures
  -> they refer to themselves in the text (= code) of the procedure

BUT:
  times-1 generates a RECURSIVE PROCESS:
  -> Each call generates deferred operations.
  -> This means it uses more space the longer it runs,
     * Which will eventually destroy it.

  times-2 generates an ITERATIVE PROCESS
  -> No deferred operations
  -> Constant amount of space -- no operations waiting to happen

times-1 uses the system to keep track of intermediate *computations*. 

times-2 uses an explicit STATE VARIABLE (result)
  -> keeps track of intermediate values.

KEY POINT:
  times-2 is TAIL RECURSIVE
  -> The last thing it does is call itself, 
  -> and there's nothing left for it to do once that call returns.
  
  * That means, that you don't need to return the value to the
    previous call of iter!  You can just return it back to iter's
    caller, times-2.

Note: something can be tail-recursive without calling itself directly! 

[Discussed in section, w/ LETREC]

Some languages optimize tail-recursive calls so that no extra space is
used for each recursive level (when it's tail recursive).  Scheme
recognizes a tail-recursive function calls, and knows not to save any
deferred operation state when it makes one.  That means, if you write
a tail-recursive function, it will run in constant space.

----------------------------------------------------------------------


Scheme has *no* special iteration constructs:
  while, do, until, loop, etc.
  
  (LIE: well, it does, but you can't use 'em yet)

  We just use tail recursion to generate iterative processes


----------------------------------------------------------------------


Next problem: 
  How do we determine whether times-1 computes the right answer?

  There are far too many possibilities for us to check them all, 

  The function clearly loses for b<0.

We'll use MATHEMATICAL INDUCTION and the Substitution Model to reason
about values. 

KEY IDEA:  Show the equivalence of a Scheme program/expression
and some mathematical statement about its value (a ``specification''
or ``contract'' that describes what the program computes).  Then can
think about the program in terms of its contract, rather than its
implementation.  Allows us to think more abstractly, and also to
depend on the given implementation to meet this abstraction.

Here's induction:
  * *The* basic proof method for CS
  * Wake up each day and wonder, "what am I gonna do induction on
    today?"
  * Induction almost exactly matches recursion.

First look at case of  N = natural numbers = {0, 1, 2, 3, ...}

Suppose that we have some property P(n) which we could ask of a
natural number
  e.g., 
        P1(n) is "n is even" 
        P2(n) is "n is the product of some number of primes"
        P3(n) is "n is the sum of four squares"
and we want to prove that P holds for all n's.

a. BASIS: 
   Prove that P holds for 0.
   (the smallest element in the set N).

b. INDUCTION:
   Prove for any n that, IF P holds for n
			 THEN P holds for n+1 as well.

Notes:
  The basis shows that P holds the smallest element (or elements)
  of the set, which is 0 for N, but other things for other sets.

So, 
  a. gives us P(0)
  b. means P(0) => P(1), so we have P(1)
  b. means P(0)/\P(1) => P(2), so we have P(2)
  ...


CONCEPTUALLY:
  "Climbing a ladder":
     The basis step shows we can get to the bottom step of the ladder.
     The induction step shows we can get from one step to the next.
  "Knocking over dominos":
     The basis step: first domino falls.
     The induction step: if N'th (and all previous) falls, so does N+1'st

Induction has a recipe.  We expect to see it in your proofs if you want full credit!

INDUCTION RECIPE:
  * What variable n are you doing induction on?
  * What is the property P(n)
  * Prove base case, typically P(0)
  * Assume P(n), prove P(n+1) 
	  
----------------------------------------------------------------------

See the handout on induction for some examples of mathematical induction
problems, and also for some other examples of inductive reasoning about
recursive procedures.  

----------------------------------------------------------------------


Now, let's try an inductive proof that (times-1 a b) = a*b for b >= 0.
[The equivalence of a Scheme program and a mathematical statement.]

Note: induction on b, not a (why?)

Note: 
      * You will be asked to do this on midterm #1 and on the final.
      * Your proof must use both the induction hypothesis and the
        substitution model to be valid (why?)

>> Gory detail just to show we *can* <<

Look at the function.  It even *looks* like an induction:
  (lambda ((a <number>) (b <integer>))
    (if (= b 0)
        0 ;; <- Basis, when b=0
        (+ a (times-1 a (- b 1))))) ;; <-- Induction step, 
                                          defining in terms of times at
                                          smaller args.
VARIABLE: b, natural number

P(b): (times-1 a b) = a*b 

BASIS:
  (times-1 a {0}) by the substitution model is
  (if (= {0} 0) 0 ...) is
  {0}

  and that is right, as a*0 = 0.

INDUCTION:
  Assume that (times-1 a b) = a*b      [this is the INDUCTION HYPOTHESIS]
  Show that (times-1 a b+1) = a*(b+1)

  (times-1 a b+1) 
==>
  (if (= b+1 0)
      0
      (+ a (times-1 a (- b+1 1))))
==>
  ;; b+1 can't be 0, since b is a natural number
  (+ a (times-1 a (- b+1 1)))
==>
  (+ a (times-1 a b))
==>
  ;; by induction hypothesis
  (+ a {a*b})
==>
  a+(ab)
=
  a*(b+1)

So, we've just shown that (times-1 a b) computes a*b for any b>=0 and
any number a.

Note that we just obtained infinitely many results!  

[Go back and answer the 2 "why" questions above.]


----------------------------------------------------------------------


This degree of effort is excessive for all but the simplest programs.

We will look more later at checking that a procedure's computation
meets certain criteria -- "specification"
  * Saying what you want is a real challenge.

Automatically generating such "correctness" proofs is an active area
of research.
  * Important for critical applications
    - Medicine -- people die when X-ray machines die
    - Aircraft control
    - Reactor control
    - Banking
    - Robotics
    - ...


----------------------------------------------------------------------


TODAY'S BIG IDEAS:

  * A syntactically *recursive* procedure can generate either a
    recursive or an iterative (=tail-recursive) process.
    The issue is, are there deferred operations?

  * Induction is used to prove things about "inductively defined sets"
    like the natural numbers.

  * Induction together with a model of evaluation (the substitution
    model) can be used to show that a procedure meets some spec, that
    is, "is correct"

New special form: LET

Induction Jokes: 
  "Prove all odd numbers are prime."
 


----------------------------------------------------------------------

Some notes on LET:

The special form LET is not really a new thing. It's just 'syntactic
sugar' for something you already can do (using lambda). For example,
the expression

  (let ((x 5))
    (+ x 10))

is equivalent to this expression using LAMBDA:

  ((lambda (x) (+ x 10)) 5) 

Similarly: 

  (let ((x 5)
	(y 10))
    (+ x y 7))                     --> 22

is equivalent to:

  ((lambda (x y) (+ x y 7)) 5 10)
                                   --> 22

Proof: Use the Substitution Model on the lambda versions!


--- Details:  Local Variables in Scheme

Local variable bindings are introduced using `let'.  The syntax of
`let' is:

      (let ((v1 <expr1>)
            (v2 <expr2>)
            ...
            (vn <exprn>))
         <body>)

Each expression <expr1> ... <exprn> is evaluated, in some unspecified
order, and then the values are bound to the corresponding new local
variables.  The <body> is evaluated, and references to the names v1,
v2, etc. are replaced by the corresponding values.

Important points:
 - All the expressions <expr1> ... <exprn> are evaluated first, before
   the names are defined.  So references to v1, v2, etc. refer to the
   values OUTSIDE the let.

 - This rule sounds similar to the Substitution model rules for
   compound procedures:  Evaluate all the arguments, then, evaluate
   the body with the names substituted by the corresponding values.
   In fact, this correspondence is useful:

   (let ((v1 EXPR1) (v2 EXPR2) ... (vn EXPRn)) BODY) ==>
   ((lambda (v1 v2 ... vn) BODY) EXPR1 EXPR2 ... EXPRn)

In the definition of `multiply-2', we used a "helper" procedure, which
we called `multiply-2-helper'.

 - Nobody but `multiply-2' cares about that helper function!

 - So, there's no need to define it as a separate procedure.

Because all the expressions are evaluated before the names are bound,
the normal version of `let' does not work for recursive procedures.
This is a half-truth: That's part of the reason, but the real reason
is more complicated than that -- it's enough to know that this will
not work the way you expect:

   (let ((FUNC (lambda ((x <integer>)) 
                 (if (zero? x) 1 (* x (FUNC (- x 1)))))))
     (func 5))

In order to define recursive functions, use `letrec' instead: It works
the same way as `let', but the names are visible to the expressions
being evaluated, so that you can define recursive procedures:

    (letrec ((v1 EXPR1) (v2 EXPR2) ... (vn EXPRn)) BODY)

We can use this to move our multiply-2-helper function "inside" the
body of multiply-2, where only it will know:

;; The same method, using letrec instead of an external function.
;; It's not really necessary to bind the helper externally!
(define multiply-2a
  (lambda ((a <number>) (b <integer>))
    (letrec ((iterate 
              (lambda ((c <integer>) (result <number>))
                (if (zero? c)
                    result
                    (iterate (- c 1) (+ result a))))))
      (iterate b 0))))

multiply-2a is essentially the same as our procedure times-2, above. 




--- If LETREC is confusing to you (at first), you can understand
almost all of the material in this lecture by using named 'helper
procedures' as below:

--- I have written all the types below so you can see them.

Scheme provides a built-in multiplication primitive (*).  But as an
example, let's look at how we might implement this ourselves.  For
simplicity, let's compute a * b where a is any number and b is a
natural number (integer >= 0).

[write this out]
;; Multiply a*b and return the result.
(define multiply-1
  (lambda ((a <number>) (b <integer>))
    (if (zero? b)
        0
        (+ a (multiply-1 
	      a 
	      (- b 1))))))

Let's trace through a computation:
 - Ignore apply stages, which are huge and basically all the same

   (multiply-1 6 3)
   (+ 6 (multiply-1 6 2))
   (+ 6 (+ 6 (multiply-1 6 1)))
   (+ 6 (+ 6 (+ 6 (multiply-1 6 0))))	;; (zero? 0) ==> #t
   (+ 6 (+ 6 (+ 6 0)))
   (+ 6 (+ 6 6))
   (+ 6 12)
   18

Notice here that at each step, we've got an addition that is waiting
for the recursive call to complete, so that it will have all its input
values.  These are called DEFERRED OPERATIONS.


Now, let us contrast `multiply-1' with the following function:

(define multiply-2-helper
  (lambda ((a <number>) (b <integer>) (result <number>))
    (if (zero? b)
	result
	(multiply-2-helper a (- b 1) (+ result a)))))

(define multiply-2
  (lambda ((a <number>) (b <integer>))
    (multiply-2-helper a b 0)))

Now, let us trace the computation again:

  (multiply-2 6 3)
  (multiply-2-helper 6 3 0)
  (multiply-2-helper 6 2 6)
  (multiply-2-helper 6 1 12)
  (multiply-2-helper 6 0 18)
  ==> 18

Note that there are no operations waiting to happen on return!

Both `multiply-1' and `multiply-2' are SYNTACTICALLY recursive: Each
procedure calls itself in the body of the procedure!

But, there is a difference:
 - A call to multiply-1 generates a stack of deferred operations

 - It takes memory to keep track of deferred operations!

 - That means the amount of space used by multiply-1 depends on the
   size of b, and if b is too big, it might become too big for the
   computer to handle.

In contrast, 
 - A call to multiply-2-helper generates no deferred operations.

 - Each time it calls itself, the value it gets back is simply
   returned, no further work is done!

 - Thus, it doesn't need to consume any memory to keep track of
   deferred operations, and multiply-1 runs in a CONSTANT amount of
   space, INDEPENDENT of the value of b.

Key idea:
 - A recursive procedure which has this property:
   No deferred operations
   ... is said to be TAIL RECURSIVE.

   - Nothing left to do once the recursive call returns.
   - Just return the value the recursion produced.

Scheme recognizes a tail-recursive function calls, and knows not to
save any deferred operation state when it makes one.  That means, if
you write a tail-recursive function, it will run in constant space.
